/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

module alias O = OuterIstToIR;

module NameMangler;
// Name mangling ala g++ or clang++
// (https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling)

// SkipRObj*
const skipRObjPtr: TypeBase = Ptr{child => LiteralSeq["skip", "RObj"]};
const skipOptRObjPtr: TypeBase = Ptr{child => LiteralSeq["skip", "OptRObj"]};

// SkipString
const skipString: TypeBase = LiteralSeq["skip", "String"];
const skipOptString: TypeBase = LiteralSeq["skip", "OptString"];

// This is the name mangling back-reference cache.  Using a back-reference is
// required to ensure that your names match the names generated by gcc.
//
private mutable class Cache{
  cache: mutable UnorderedMap<TypeBase, Int> = mutable UnorderedMap[],
} {
  // Look up 't'.  If it's already in the cache then return the string to use it
  // - otherwise call 'f' to generate and cache a new type string.
  mutable fun getOrAdd(t: TypeBase, f: () -> String): String {
    this.cache.maybeGet(t) match {
    | Some(i) if (i == -1) -> "S_"
    | Some(i) -> `S${i}_`
    | None() ->
      result = f();
      this.cache![t] = this.cache.size() - 1;
      result
    }
  }
}

base class TypeBase{} uses Hashable, Equality {
  static fun fromType(
    t: Type,
    fs: mutable O.FunSpecializer,
    _pos: Pos,
  ): ?TypeBase {
    shape = fs.scalarize(t);
    flatShape = shape.flattened();
    if (t == tVoid || flatShape.size() == 0) {
      return None()
    };

    Some(
      if (t == tBool) {
        Simple{id => "b"} // bool
      } else if (t == tChar) {
        Simple{id => "Di"} // char32_t
      } else if (t == tFloat) {
        Simple{id => "d"} // double
      } else if (t == tInt) {
        Simple{id => "x"} // long long
      } else if (t == tString) {
        skipString
      } else if (t == tInt8) {
        Simple{id => "a"} // signed char
      } else if (t == tInt16) {
        Simple{id => "s"} // short
      } else if (t == tInt32) {
        Simple{id => "i"} // int
      } else if (t == tIntPtr) {
        Simple{id => "x"} // __int64_t
      } else if (t == tNonGCPointer) {
        Ptr{child => Simple{id => "v"}} // void*
      } else if (t == tGCPointer) {
        skipRObjPtr
      } else {
        if (flatShape.size() == 1 && fs.maybeGetScalarType(t).isSome()) {
          // It's just a normal pointer
          skipRObjPtr;
        } else if (
          flatShape.size() == 2 &&
          flatShape[0].i1 == tInt &&
          flatShape[1].i1 == tInt
        ) {
          NameMangler.LiteralSeq["SkipRetValue"]
        } else {
          name = fs.specializer.exampleSClass(t).toString();
          NameMangler.LiteralSeq::fromQualifiedName(name)
        }
      },
    )
  }

  fun toString(cache: mutable Cache): String;

  // toString() wraps a LiteralSeq in "nested name" markers.  If we need to
  // avoid that use toInnerString() directly.
  overridable fun toInnerString(cache: mutable Cache): String {
    this.toString(cache)
  }
}

fun fromNonVoidType(
  t: Type,
  fs: mutable O.FunSpecializer,
  pos: Pos,
): ?TypeBase {
  TypeBase::fromType(t, fs, pos)
}

fun fromType(t: Type, fs: mutable O.FunSpecializer, pos: Pos): TypeBase {
  fromNonVoidType(t, fs, pos) match {
  | Some(s) -> s
  | None() -> Simple{id => "v"}
  }
}

class Ptr{child: TypeBase} extends TypeBase {
  fun toString(cache: mutable Cache): String {
    cache.getOrAdd(this, () -> "P" + this.child.toString(cache))
  }

  fun ==(tb: TypeBase): Bool {
    tb match {
    | Ptr{child} -> this.child == child
    | _ -> false
    }
  }
}

class Simple{id: String} extends TypeBase {
  fun toString(_cache: mutable Cache): String {
    this.id
  }

  fun ==(tb: TypeBase): Bool {
    tb match {
    | o @ Simple _ -> this.id == o.id
    | _ -> false
    }
  }
}

class Literal{name: String} extends TypeBase {
  fun toString(cache: mutable Cache): String {
    cache.getOrAdd(this, () -> {
      s = UTF8String::make(this.name);
      `${s.utf8.size()}${this.name}`
    })
  }

  fun ==(tb: TypeBase): Bool {
    tb match {
    | o @ Literal _ -> this.name == o.name
    | _ -> false
    }
  }
}

class LiteralSeq{
  prefix: TypeBase, // LiteralSeq or Literal
  name: String,
} extends TypeBase {
  static fun createFromItems<I: readonly Sequence<String>>(items: I): TypeBase {
    seq: ?TypeBase = None();
    for (i in items) {
      !seq = seq match {
      | Some(prefix) -> Some(LiteralSeq{prefix, name => i})
      | None() -> Some(Literal{name => i})
      }
    };
    seq.fromSome()
  }

  // Split a name such as Foo.Bar::Baz into its component parts.  Need to be
  // careful because the NBE uses names with dots in them - so only split on the
  // first dot (which separates the module from the rest).
  static fun fromQualifiedName(name: String): TypeBase {
    // HACK: Remove any template parameter
    !name = name.split("<")[0];

    parts = name.split("::");
    seq = Vector["SKIP"].concat(parts[0].split(".").concat(parts.slice(1))).map(
      p -> p.replaceRegex(Regex::create("[^A-Za-z0-9_]"), _ -> "_"),
    );

    LiteralSeq::createFromItems(seq);
  }

  fun toString(cache: mutable Cache): String {
    cache.getOrAdd(this, () -> {
      s = UTF8String::make(this.name);
      `N${this.prefix.toInnerString(cache)}${s.utf8.size()}${this.name}E`
    })
  }

  fun toInnerString(cache: mutable Cache): String {
    cache.getOrAdd(this, () -> {
      s = UTF8String::make(this.name);
      `${this.prefix.toInnerString(cache)}${s.utf8.size()}${this.name}`
    })
  }

  fun ==(tb: TypeBase): Bool {
    tb match {
    | o @ LiteralSeq _ -> this.prefix == o.prefix && this.name == o.name
    | _ -> false
    }
  }
}

class Template{name: TypeBase, params: Array<TypeBase>} extends TypeBase {
  fun toString(cache: mutable Cache): String {
    cache.getOrAdd(this, () ->
      ("N" +
        this.name.toInnerString(cache) +
        "I" +
        this.params.map(p -> p.toString(cache)).join("") +
        "EE")
    )
  }

  fun ==(tb: TypeBase): Bool {
    tb match {
    | o @ Template _ -> this.name == o.name && this.params == o.params
    | _ -> false
    }
  }
}

class Function{returnType: TypeBase, params: Array<TypeBase>} extends TypeBase {
  fun toString(cache: mutable Cache): String {
    cache.getOrAdd(this, () ->
      ("F" +
        this.returnType.toString(cache) +
        this.params.map(p -> p.toString(cache)).join("") +
        "E")
    )
  }

  fun ==(tb: TypeBase): Bool {
    tb match {
    | o @ Function _ ->
      (this.returnType == o.returnType && this.params == o.params)
    | _ -> false
    }
  }
}

private class Seq{parts: Array<TypeBase>} extends TypeBase {
  static fun createFromItems<I: readonly Sequence<TypeBase>>(
    items: I,
  ): TypeBase {
    Seq{parts => items.collect(Array)}
  }

  fun toString(cache: mutable Cache): String {
    this.parts.map(p -> p.toString(cache)).join("")
  }

  fun ==(tb: TypeBase): Bool {
    tb match {
    | o @ Seq _ -> this.parts == o.parts
    | _ -> false
    }
  }
}

fun toString(t: ?TypeBase): String {
  cache = mutable Cache{};
  t match {
  | Some(s) -> s.toString(cache)
  | None() -> "<None>"
  }
}
