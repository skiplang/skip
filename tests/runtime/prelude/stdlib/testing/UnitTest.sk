/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Helper classes for writing unit tests of Skip code.
 *
 * *** Writing Tests ***
 *
 * Write your tests as global functions annotated with `@test`:
 *
 *     @test
 *     fun testFoo(): void {
 *       ..
 *     }
 *
 *     @test
 *     fun testBar(): void {
 *       ...
 *     }
 *
 * *** Assertions ***
 *
 * The test is considered failing if it throws an exception and passing
 * otherwise. To throw exceptions, you can use the functions in Assert.sk:
 *
 *     @test
 *     fun testFoo(): void {
 *       assertEqual(2, 2);
 *       assertDoesNotThrow(() -> 2 + 3);
 *     }
 *
 * *** Running Tests ***
 *
 * There is an automatic test runner at prelude/testing/run_test that will run
 * tests for you. Invoke it as:
 *
 *     prelude/testing/run_test ./skip_eval prelude/__tests__/OrderedMapTest.sk
 *
 * The runner will find and run all methods annotated with `@test`.
 */
module UnitTest;

untracked fun main(tests: Array<(String, untracked () -> void)>): void {
  args = arguments().values().drop(4); // first 4 arguments are tested by SystemTest
  backendGen = "";
  testFile = "";
  expectError = false;
  allowEmpty = false;
  options = Options{};
  try {
    loop {
      args.next() match {
      | Some("--backend-gen") ->
        !backendGen = args
          .next()
          .fromSome("Missing value for --backend-gen <value>")
      | Some("--test-file") ->
        !testFile = args
          .next()
          .fromSome("Missing value for --test-file <value>")
      | Some("--color-success") ->
        !options.colorSuccess = args
          .next()
          .fromSome("Missing value for --color-success <value>")
      | Some("--color-failure") ->
        !options.colorFailure = args
          .next()
          .fromSome("Missing value for --color-failure <value>")
      | Some("--color-end") ->
        !options.colorEnd = args
          .next()
          .fromSome("Missing value for --color-end <value>")
      | Some("--expect-error") ->
        args.next() match {
        | Some("true") -> !expectError = true
        | Some("false") -> !expectError = false
        | _ ->
          invariant_violation(
            "Missing value (true/false) for --expect-error <value>",
          )
        }
      | Some("--allow-empty") -> !allowEmpty = true
      | Some(str) -> invariant_violation(`Unexpected argument ${str}`)
      | None() -> break void
      }
    };
  } catch {
  | exn ->
    debug(arguments());
    throw exn
  };
  projectName = `${backendGen} ${testFile}`;
  if (!allowEmpty && tests.isEmpty()) {
    print_error_ln(
      "No tests provided: use `--allow-empty` if this is expected.",
    );
    exit(2)
  };
  runTests(tests, projectName, expectError, options)
}

untracked fun runTests(
  tests: Array<(String, untracked () -> void)>,
  projectName: String,
  expectError: Bool,
  options: Options,
): void {
  print = if (expectError) {
    print_error_ln
  } else {
    print_string
  };
  for ((testName, test) in tests) {
    name = `${projectName} ${testName}`;
    // Note: cannot use Result::guard with an untracked lambda
    result = try {
      Success(test())
    } catch {
    | exn -> Failure(exn)
    };
    result match {
    | Success _ -> print(reportSuccess{name, options})
    | Failure(exception) ->
      print(reportFailure{name, exception, options});
      exit(1)
    }
  }
}

private fun statusLine{name: String, success: Bool, options: Options}: String {
  result = {
    if (success) "[OK]" else "[FAILED]"
  };
  color = if (success) options.colorSuccess else options.colorFailure;
  padding = max(1, 80 - name.length() - result.length());
  spaces = " ".repeat(padding);
  name + spaces + color + result + options.colorEnd
}

private fun reportSuccess{name: String, options: Options}: String {
  statusLine{name, success => true, options}
}

private fun reportFailure{
  name: String,
  exception: Exception,
  options: Options,
}: String {
  messages = mutable Vector[];
  messages.push(statusLine{name, success => false, options});
  exception match {
  | e2 @ AssertionFailure _ ->
    messages.push("Assertion failed: " + e2.message);
    messages.push("Expected: " + e2.expected);
    messages.push("Actual:   " + e2.actual)
  | _ -> messages.push(exception.getMessage())
  };
  messages.join("\n")
}

class Options{
  colorSuccess: String = "",
  colorFailure: String = "",
  colorEnd: String = "",
}
module end;
